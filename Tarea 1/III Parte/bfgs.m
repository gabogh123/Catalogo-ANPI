function res = bfgs()  pkg load symbolic %Se carga el paquete symbolic   xk = [3;2;5;3;4;5]; % x0  n = length(xk);    gk = get_gradient_qingfcn(xk);  % gradiente g(xk)        Bk = eye(n);   % matriz identidad nxn donde n=cantidad de variables de entrada    iterMax = 1000;  tolerancia = 0.00001;  iteraciones = [];  errores = [];      % Tomar en cuenta que las variables pueden ser vectores o matrices    for i=1:iterMax       % Obtener pk de la ecuacion: Bk*pk = -g(xk), donde g(xk) es el gradiente de la funcion, entonces pk = Bk^-1 * -gk   Bk_inv = inv(Bk);   pk = Bk_inv * -gk;               % Determinar el stepsize con 位k > 0 a partir de: f(xk + 位k*pk) <= f(xk) + delta*位k*g(xk)^T * pk      lambda = stepsize2(xk, pk, gk);   pklambda = lambda*pk;   % A partir de estos valores calcular xk+1 = xk_pasado + 位k*pk      % primero guardamos los xk y gk anteriores para usarlos al calcular xk+1, sk y yk   xk_pasado = xk;   gk_pasado = gk;      % se calcula el nuevo xk y gk   xk = xk + (lambda*pk);   gk = get_gradient_qingfcn(xk);      % Luego calcular Bk+1 con su respectiva funcion (2.10 en el documento) donde sk = xk - xk_pasado y yk = gk - gk_pasado      % calculando sk y yk      sk = xk - xk_pasado;   yk = gk - gk_pasado;         sk_t = transpose(sk);   yk_t = transpose(yk);               % Calculando el valor de Bk donde si se cumple cierta condicion cambia y si no la cumple se queda igual.   if (((yk_t * sk) / norm(sk)^2) >= norm(gk))            der = ((yk*yk_t) / (yk_t*sk));      izq = ((Bk*sk*sk_t*Bk) / (sk_t*Bk*sk));            Bk = Bk - izq + der;   else            Bk = Bk;   endif            % Agregando los valores para graficar   iteraciones = [iteraciones ; i];   errores = [errores ; norm(gk)];      % condicion de parada -> norm(gk)   if (norm(gk) < tolerancia)     disp("buenas");   endif
     endfor
  plot(iteraciones, errores);     res = 1;endfunction res = get_gradient_qingfcn(xk)  g_vec = [];  for i = 1:length(xk)        g = 4*xk(i) * (xk(i)^2 - i);    g_vec = [g_vec ; g];  endfor  res = g_vec;  endfunction res = stepsize(xk, pk, gk)   delta = 0.5;   lambda = 1;   iterMaxLambda = 1000;   for j=1:iterMaxLambda     izq = qingfcn(xk + lambda*pk);     der = qingfcn(xk) + delta*lambda*sum(gk'*pk);     if (izq <= der)       break;     else      lambda = lambda/2;       endif    endfor      res = lambda;endfunction res = stepsize2(xk, pk, gk)  delta = 0.5;  lambda = 0.8;  xk_lambda = xk + lambda * pk;    f1 = qingfcn(xk_lambda);  f2 = qingfcn(xk);    while (f1 > f2 + delta*lambda*transpose(gk)*pk)    lambda = lambda*0.8;    xk_lambda = xk + lambda*pk;    f1 = qingfcn(xk_lambda);    endwhile        res = lambda;
endfunction res = qingfcn(x)    n = size(x, 2);    x2 = x .^2;        res = 0;    for i = 1:n        res = res + (x2(:, i) - i) .^ 2;    endend   