function p3_bfgs()  pkg load symbolic %Se carga el paquete symbolic   f = 'x^2'; %String que representa la funcion a evaluar  xk = randi([0 10],1,5)  xk = xk'; %Vector con valores iniciales  tol = 0.00001; %Valor de tolerancia aceptada  iterMax = 250;  tolerancia = 0.00001;   bfgs(f,xk,tol,iterMax, tolerancia)      end      function bfgs(f,xk,tol,iterMax, tolerancia)  % se define el xk inicial    %xk = [2;0;3;8;1;0]  n = length(xk);      % se define la funcion de prueba   f1 = matlabFunction(sym (f))  x = sym('x');  % se define el gradiente de la funcion de prueba  grad_f = matlabFunction(gradient(f1,[x]))   %calculo del gradiente  gk = get_gradient(xk, grad_f);      Bk = eye(n);   % matriz identidad nxn donde n=cantidad de variables de entrada      iteraciones = [];  errores = [];           for i=1:iterMax       % Obtener pk de la ecuacion: Bk*pk = -g(xk), donde g(xk) es el gradiente de la funcion, entonces pk = Bk^-1 * -gk   Bk_inv = inv(Bk);   pk = Bk_inv * -gk;               % Determinar el stepsize con 位k > 0 a partir de: f(xk + 位k*pk) <= f(xk) + delta*位k*g(xk)^T * pk      lambda = stepsize(xk, pk, gk, f1);      % A partir de estos valores calcular xk+1 = xk_pasado + 位k*pk      % primero guardamos los xk y gk anteriores para usarlos al calcular xk+1, sk y yk   xk_pasado = xk;   gk_pasado = gk;      % se calcula el nuevo xk y gk   xk = xk + (lambda*pk);   gk = get_gradient(xk, grad_f);   %gk = grad_f(xk(1), xk(2), xk(3), xk(4), xk(5))       % Luego calcular Bk+1 con su respectiva funcion (2.10 en el documento) donde sk = xk - xk_pasado y yk = gk - gk_pasado      % calculando sk y yk      sk = xk - xk_pasado;   yk = gk - gk_pasado;         sk_t = transpose(sk);   yk_t = transpose(yk);               % Calculando el valor de Bk donde si se cumple cierta condicion cambia y si no la cumple se queda igual.   if (((yk_t * sk) / norm(sk)^2) >= norm(gk))            der = ((yk*yk_t) / (yk_t*sk));      izq = ((Bk*sk*sk_t*Bk) / (sk_t*Bk*sk));            Bk = Bk - izq + der;   else            Bk = Bk;   endif            % Agregando los valores para graficar   iteraciones = [iteraciones ; i];   errores = [errores ; norm(gk)];      % condicion de parada -> norm(gk)   if (norm(gk) < tolerancia)     disp("CONDICION DE PARADA CUMPLIDA");     break;   endif
     endfor
  plot(iteraciones, errores);     endfunction res = get_gradient(xk, grad_f)    g_vec = [];  for i = 1:length(xk)        g = grad_f(xk(i));    g_vec = [g_vec ; g];  endfor  res = g_vec;  endfunction res = stepsize(xk, pk, gk, spherefcn)  delta = 0.5;  lambda = 0.8;  xk_lambda = xk + lambda * pk;  f1 = spherefcn(xk_lambda);  f2 = spherefcn(xk);    while (f1 > f2 + delta*lambda*transpose(gk)*pk)    lambda = lambda*0.8;    xk_lambda = xk + lambda*pk;    f1 = spherefcn(xk_lambda);    endwhile        res = lambda;
endfunction res = qingfcn(x)    n = size(x, 2);    x2 = x .^2;        res = 0;    for i = 1:n        res = res + (x2(:, i) - i) .^ 2;    endend   